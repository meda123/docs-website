---
title: メモリ使用量が多い場合のトラブルシューティング (Node.js)
type: troubleshooting
tags:
  - Agents
  - Nodejs agent
  - Troubleshooting
metaDescription: If you installed the New Relic Node.js agent and your application's memory usage increases read this troubleshooting doc for potential causes and solutions.
translationType: machine
---

## 問題

New Relic Node.js エージェントをインストールしたところ、Node.js アプリケーションのメモリ使用量が増加しました。

## 解決

このメモリの増加にはいくつかの原因が考えられ、それぞれに解決策があります。

<CollapserGroup>
  <Collapser
    id="slab"
    title="TLSのメモリバッファの割り当てによる増加"
  >
    Node.jsアプリケーションが、SSLやHTTPSを含む何らかの形の暗号化を初めて使用する際には、 [スラブバッファ](http://en.wikipedia.org/wiki/Slab_allocation) が作成されます。このバッファのデフォルトサイズは10MBです。

    受信リクエストに対するSSLの終端が別のルーター層で行われる環境で動作するアプリケーションでは、通常、このオーバーヘッドは発生しません。Heroku や AWS のようなクラウド・サービスは、しばしばこのように動作します。しかし、Node.js のエージェントは New Relic のサービスに HTTPS でアウトバウンド・データを送信しており、これがスラブ・バッファの割り当てのきっかけとなっています。

    **解決：**

    場合によっては、スラブバッファをデフォルトの10MBよりも小さくすることができます。

    スラブ バッファ サイズを設定するには、 [`tls.SLAB_BUFFER_SIZE`](http://nodejs.org/api/tls.html#tls_tls_slab_buffer_size)を使用します。

    <Callout variant="caution">
      New Relic エージェントを使用する場合は、スラブバッファサイズを 128 KB 未満に設定しないでください。SSLやHTTPSなどの暗号を使ってサービスやクライアントと通信するアプリでは、スラブバッファの割り当てを減らしてはいけません。
    </Callout>
  </Collapser>

  <Collapser
    id="cluster"
    title="クラスタワーカーのスラブ割り当てによる増加"
  >
    Node.jsは、 [クラスタモジュール](http://nodejs.org/api/cluster.html) を提供しています。これにより、ホスト上で利用可能なすべてのプロセッサコアを使用して、リクエストを並行して処理することができます。しかし、各クラスタワーカーは、SSL トランザクション用に独自のスラブバッファを割り当て、Node.js エージェントデータのコピーを保持します。このため、使用するクラスター・ワーカーの数だけメモリ・オーバーヘッドが増加します。

    これは、ホストが複数のNode.jsアプリケーションを同時に実行する場合にも当てはまります。

    **解決：**

    クラウドサービスプロバイダーの中には、実際に使用できるプロセッサコア数よりも多くのプロセッサコアを使用する環境を使用しているところがあります。クラスターワーカーの数を減らしたり、クラスターのサポートを受けずに動作させたりすることで、パフォーマンスに影響を与えることなくメモリ使用量を減らすことができます。
  </Collapser>

  <Collapser
    id="log"
    title="ディスクに保存されたログメッセージによる増加"
  >
    ログメッセージはデフォルトではディスクに記録されます。メッセージデータの処理方法により、メッセージオブジェクトはガベージコレクションのために **Old-pointer-space** に移動されることがあります。これは、オブジェクトへの参照がすべてなくなった後も、しばらくの間、オブジェクトがメモリ内に残ることを意味します。これにより、プロセスが常に消費するメモリの量が多くなります。また、ガベージコレクションのために追加の処理時間が使われます。

    **解決：**

    Node.js のバージョンによっては、エージェントがデフォルトで`trace`または`info`ログ レベルになる場合があります。ロギングの詳細度を`info`または`warn`レベルに下げて、メモリ使用量とガベージ コレクションに費やされる時間を大幅に減らします。
  </Collapser>

  <Collapser
    id="mongo"
    title="MongoDBのカーソルが流出することによる増加"
  >
    多くのデータベース ドライバは、 `cursor`と呼ばれる抽象化を使用します。カーソルは、クエリの結果を反復処理する機能を提供します。たとえば、 **mongodb**ドライバーは、 `find`クエリを実行するときにカーソルを提供します。

    カーソルは、Node.js ランタイムではオブジェクトとして、MongoDB サーバーではエンティティとして存在します。アプリケーションが`cursor`の使用を終了したら、それを閉じて、サーバー アプリケーションとクライアント アプリケーションの両方でリソースを解放する必要があります。

    Node.js では、サーバーで`cursor`を閉じることなく、カーソルをガベージ コレクションしてアプリケーションのリソースを解放することができます。これは、アプリケーションでは見過ごされる可能性があります。ただし、New Relic Node.js エージェントは開いているカーソルを追跡して、結果の反復処理に費やされた時間を測定します。アプリケーションが使用するすべてのカーソルを閉じない場合、エージェントは引き続き古いカーソルを追跡し、メモリ リークを引き起こします。

    **解決：**

    アプリケーションがクエリの結果の処理を終了した後、 `cursor.close()`を呼び出して、アプリケーションで作成されたすべての`cursor`が閉じられていることを確認します。
  </Collapser>

  <Collapser
    id="agent"
    title="エージェントのデータ保存による増加"
  >
    Node.jsエージェントは、アプリが処理する各トランザクションのデータを記録します。データは通常、トランザクション名でグループ化されます。エージェントが使用するメモリは、1分ごとの収穫サイクルで記録される異なるトランザクションの数に応じて増加します。

    また、各トランザクションの間、より多くのデータが保持されますが、最終的にはトランザクションの完了時に破棄されます。エージェントが使用するメモリは、アプリケーションが処理する同時トランザクションの数に応じて増加します。

    **解決：**

    エージェントデータストレージがメモリ使用量の増加の原因であると判明した場合、ホストにメモリを追加するか、より大きなクラウドインスタンスに変更することで対処できます。
  </Collapser>
</CollapserGroup>