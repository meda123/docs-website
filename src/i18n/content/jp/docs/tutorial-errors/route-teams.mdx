---
title: エラーをチームに割り当て、エラーステータスを更新する
metaDescription: Learn how to manage a high number of errors in your app.
translationType: machine
---

import apmErrorsAssign from 'images/apm_screenshot-crop_errors-triage.webp'

import apmErrorsStatus from 'images/apm_screenshot-crop_errors-status.webp'

import apmErrorsAssignment from 'images/apm_screenshot-crop_errors-assignment.webp'

停止の全範囲とエラー グループを理解したので、エラーを割り当て、そのステータスを更新できます。New Relic 内でエラーを割り当てると、収集したすべての情報をコード所有者に転送できます。エラー受信箱を管理すると、複数のチームにわたる情報のサイロが排除され、解決プロセスが迅速化されます。

## 目的 [#objectives]

このチュートリアルでは、修正をより迅速に展開できるようにエラーを管理する方法を説明します。

* エラーを正しいチームに割り当てる方法を学ぶ
* エラーのステータスを更新する

## エラーグループを管理する [#manage]

<Steps>
  <Step>
    ### エラーを正しいチームに割り当てる

    **Error group summary** \[エラー グループの概要] ページから、エラー グループを正しいチームに割り当てることができます。

    <img
      title="Overview errors affecting your services"
      alt="A screenshot showing an app with many errors"
      src={apmErrorsAssign}
    />

    エラーを個人またはチームに割り当てると、コミュニケーション上のミスが発生する可能性がなくなります。エラーの解決に役立つ情報はコード所有者に直接配信され、コード所有者は中断したところから作業を再開できるようになります。

    その後、課題は電子メールでチームに配信されます。

    <img
      title="Overview errors affecting your services"
      alt="A screenshot showing an app with many errors"
      src={apmErrorsAssignment}
    />
  </Step>

  <Step>
    ### エラーのステータスをマークします

    割り当てが完了すると、エラーのステータスを更新できます。

    <img
      title="Overview errors affecting your services"
      alt="A screenshot showing an app with many errors"
      src={apmErrorsStatus}
    />

    この機能には、いくつかの異なる利点があります。

    * エラー グループが予期される場合は、エラーを **Ignored**としてマークできます。予期されるエラーは、あなたとチームが知っています。重大ではないバグである場合もあれば、エンド ユーザーに関連するエラー (誰かが間違ったパスワードを使用している場合など) である場合もあります。
    * ただし、予想されるエラーをできる限り解決することをお勧めします。エラー グループを無視しても、今後 New Relic がエラーを報告することは妨げられず、これがデータの取り込みに影響します。
    * New Relic は、エラーのステータスを時間の経過とともに追跡します。たとえば、エラー グループを **Resolved** \[解決済み] としてマークした後、新しいデプロイメントでエラー グループが表示された場合、New Relic はそのエラーを **Regression**としてマークします。
  </Step>

  <Step>
    ### 根本原因を調査する

    一般的なエラーを削減する場合でも、重大な機能停止に対応する場合でも、エラー発生の直接の原因につながるデータを追跡することになります。庭に水浸しになったパイプの漏れは修理したかもしれませんが、そもそも亀裂の原因は見つかっていません。

    エラー グループをチームに割り当てると、どのプロセスが停止につながったのかを全員で特定する振り返りの開催が容易になります。ひびの入ったパイプを元に戻すには、配管工に会い、庭の木がすべてのパイプに成長していると教えてくれました。全員が同じデータを確認できる振り返りは、チームのワークフロー全体の改善に自然とつながります。

    サービス停止の一般的な根本原因は次のとおりです。

    * 実稼働前環境での不適切な保証テスト。
    * コードベース内のすべての関数またはメソッドをテストして、結果が期待どおりであることを確認できない。
    * 上流の依存関係の要件、容量、またはその制限について誤解しています。たとえば、データベース クエリが実稼働前では負荷が低くても問題なく実行されていたが、負荷がかかると速度が低下し始めた場合です。
    * 容量計画の欠如。おそらく、コードは通常の負荷ではすべての通常のテストに合格しますが、需要がピークに達すると実行されなくなる可能性があります。

    根本原因は、存在するチームの数と同じくらい変化する可能性があります。ただし、重要なのは、データを追跡し、コミュニケーションをとり、直接的な原因を超えて深く掘り下げることです。
  </Step>
</Steps>

## 次は何ですか？ [#next]

エラー受信箱を使用してエラーを診断および解決する方法を学習したので、他のチュートリアルを探索してください。

* アプリの動作が遅いですか?「アプリ [が遅い」](docs/tutorial-app-slow/root-causes) チュートリアルで、アプリの遅延を優先順位付けして診断する方法を学びましょう。
* ピーク需要の日が近づいている場合は、New Relic が [容量計画](/docs/tutorial-peak-demand/get-started)にどのように役立つかをご覧ください。
* 高品質のアラートを作成したいですか?[アラート チュートリアルは、](/docs/tutorial-create-alerts/create-new-relic-alerts/) アラート システムのセットアップに役立ちます。

<UserJourneyControls previousStep={{"path":"/docs/tutorial-errors/solve-critical-errors","title":"一つ前の手順","body":"サービス停止の原因となったシステム内のエラーを特定します。"}}/>