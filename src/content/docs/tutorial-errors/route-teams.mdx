---
title: Assign errors to teams and update error status
metaDescription: Learn how to manage a high number of errors in your app.   
---

import apmErrorsAssign from 'images/apm_screenshot-crop_errors-triage.webp'

import apmErrorsStatus from 'images/apm_screenshot-crop_errors-status.webp'

import apmErrorsAssignment from 'images/apm_screenshot-crop_errors-assignment.webp'


Now that you understand the full scope of your outage and the error group, you can assign the error and update its status. When you assign errors within New Relic, you can transfer all the information you've gathered to the code owners. Managing your errors inbox eliminates information silos across multiple teams, which expedites the resolution process. 

## Objectives [#objectives]

This tutorial guides you through managing your errors so you can deploy fixes faster:

* Learn to assign errors to the correct teams
* Update the status of your errors

## Manage your error groups [#manage]

<Steps>
    <Step>

### Assign the error to the correct team
        
From the **Error group summary** page, you can assign the error group to the correct team. 

    <img
        title="Overview errors affecting your services"
        alt="A screenshot showing an app with many errors"
        src={apmErrorsAssign}
    />  

Assigning an error to a person or team eliminates possible miscommunications. The information that helped you solve the error is delivered directly to the code owner, allowing them to pick up where you left off. 

The assignment is then delivered to the team via email:

    <img
        title="Overview errors affecting your services"
        alt="A screenshot showing an app with many errors"
        src={apmErrorsAssignment}
    />  

    </Step>
    <Step>

### Mark the status of the error 

Once assigned, you can update the status of an error. 

    <img
        title="Overview errors affecting your services"
        alt="A screenshot showing an app with many errors"
        src={apmErrorsStatus}
    />  

This functionality has a few different benefits:

* If an error group is expected, you can mark the error as **Ignored**. Expected errors are known to you and the team â€” they can be noncritical bugs, or they can be errors associated with the end user (like someone using an incorrect password). 
* We recommend resolving expected errors as much as you can, however. Ignoring an error group doesn't prevent New Relic from reporting the error in the future, which contributes to your data ingest. 
* New Relic tracks the status of an error over time. For example, if you mark an error group as **Resolved** but it appears at a later point with a new deployment, New Relic will mark that error as a **Regression**.


    </Step>
    <Step>

### Investigate the root cause

Whether you're reducing common errors or reacting to a critical outage, you're following data that leads you to the direct cause of an error occurrence. You may have fixed the leaking pipe that flooded your yard, but you haven't discovered what caused the crack in the first place. 

When you assign error groups to teams, it's easier to hold retrospectives where everyone identifies what processes led to an outage. To bring it back to your cracked pipe: you meet with a plumber and they tell you that the trees in your yard are growing into all of your pipes. Retrospectives where everyone can look at the same data naturally leads to improvements to the overall workflow of your team. 

Here are some common root causes to service outages:

* Improper assurance testing in pre-production environments. 
* Failing to test every function or method within a codebase to ensure the results are as expected.
* Misunderstanding upstream dependency requirements, capacity, or its limitations. For example, if a database query runs great in pre-production with smaller loads, but under stress begins to slow. 
* Lack of capacity planning. Maybe your code passes all its usual tests under ordinary loads, but when demand peaks, it doesn't perform. 

Root cause can be as variable as the number of teams that exist. The takeaway, though, is to follow the data, communicate, and dig deeper beyond direct cause. 

    </Step>
</Steps>

## What's next? [#next]

Now that you've learned how to use errors inbox to diagnose and resolve errors, you can explore our other tutorials:

* Is your app running slow? Learn how to triage and diagnose latency in your app with our [My app is slow](docs/tutorial-app-slow/root-causes) tutorial.
* If you have a peak demand day coming up, learn how New Relic can help you with [capacity planning](/docs/tutorial-peak-demand/get-started).
* Do you want to create high quality alerts? Our [alerts tutorial](/docs/tutorial-create-alerts/create-new-relic-alerts/) can help you set up an alerting system.  

<UserJourneyControls
    previousStep={{path: "/docs/tutorial-errors/solve-critical-errors", title: "Previous step", body: "Locate the error in your system that led to a service outage."}}
/>